'''
for i in range      ИНДЕКС
for item in range   САМ ЭЛЕМЕНТ

КОЛЛЕКЦИИ типов ДАННЫХ (обращаться по индексу(кроме dict, set), перебирать с помощью циклов)
строка      str_ = ""           индексируемый НЕИЗМЕНЯЕМЫЙ тип данных - пересоздавая строку - в компьютере создается новый адрес занимаемой памяти
список      list_ = []          индексируемый УПОРЯДОЧЕННЫЙ ИЗМЕНЯЕМЫЙ КОНЕЧНЫЙ набор эл-тов
кортеж      tuple_ = ()         индексируемый НЕИЗМЕНЯЕМЫЙ список
словарь     dict_ = {'a':'01'}  НЕУПОРЯДОЧЕННАЯ коллекция объектов с доступом по ключу; может хранить любые типы данных; НЕ ИНДЕКСИРУЕМЫЙ
мн-во       set_ = {}           УНИКАЛЬНЫЕ НЕУПОРЯДОЧЕНЫЕ эл-ты; НЕ ИНДЕКСИРУЕМЫЙ; ИЗМЕНЯЕМЫЙ
замороженное мн-во  frozenset_ = {}     НЕИЗМЕНЯЕМЫЕ УНИКАЛЬНЫЕ НЕУПОРЯДОЧЕНЫЕ эл-ты; НЕ ИНДЕКСИРУЕМЫЙ

ПРИВЕДЕНИЕ ТИПОВ
(int, str, float, bool, list, tuple, dict, set, frozenset)
c = int(c)
c = str(c)
c = float(c)
c = bool(c)
c = list(c)
c = tuple(c)
c = dict(c)
c = set(c)
c = frozenset(c)

                                            list_ = [1, 2, 3, 4]
проверяем: содержится 2 в списке f?          print(2 in list_) # true
проверяем: НЕ содержится 2 в списке f?       print(not 2 in f) # false
проверяем факт ЧЕТНОСТИ ЧИСЛА из списка      is_odd = f[0] % 2 == 0 # false
                                            print(is_odd)

СТРОКИ и СПИСКИ: СРЕЗЫ, ОБРАЩЕНИЕ ПО ИНДЕКСУ;
len - размер
str_[::6]) - вывести элементы с 0-го до конца всей строки с шагом 6
str_[:]) # вывести абсолютно все символы
str_[2:9]) # вывести элементы со 2-го по 9-й НЕ включая его



ФУНКЦИИ для СПИСКОВ list
list_[i]                обращение по индексу
print(list_[i:j:step])	извлечение среза
print(len(list_))       длина списка

.reverse()      разворачивает список
.clear()        очищает список
.append(<a>)    добавить элемент в конец
.remove(<a>)    удалить элемент ИЛИ удалить 1-й элемент в списке, имеющий значение a. ValueError, если такого элемента не существует
.insert(<индекс куда встав эл>, <знач-е, кот встав>) добавление элемента в список на нужную позицию
.del a[0]       удалить элемент
.pop            удаление+возвращение последнего элемента
.pop()     удаляет последний элемент и возвращает его без скобок []; если после вывести список - удаленного значения в нем не будет
.pop(0)    удаляет элемент по индексу
.extend(list__)         Расширяет список list_, добавляя в конец все элементы списка list__
.sort([key=функция])    Сортирует список на основе функции

range - генерирует последовательность, принимает 3 аргумента: откуда начинаем (по умолчанию = 0), на каком числе заканчиваем, шаг (по умолчанию шаг = 1).
r = range(5) # 0 1 2 3 4

заполним пустой список поочередно значениями 
list_3 = []
print(list_3)
for i in range(5):
    list_3.append(i)
    print(list_3)

??? list_.index(x, [start [, end]])	Возвращает положение первого элемента со значением x (при этом поиск ведется от start до end)
??? list_.count(x)	Возвращает количество элементов со значением x
??? list_.copy()	Поверхностная копия списка



ФУНКЦИИ для СТРОК str


в строках сравниваются символы кодировки, поэтому заглавные буквы будут МЕНЬШЕ прописных    print("i" > "I") #true

S[i]	Обращение по индексу
S[i:j:step]	Извлечение среза
len(S)	Длина строки
S.find(str, [start],[end])	Поиск подстроки в строке. Возвращает номер первого вхождения или -1
S.rfind(str, [start],[end])	Поиск подстроки в строке. Возвращает номер последнего вхождения или -1
S.index(str, [start],[end])	Поиск подстроки в строке. Возвращает номер первого вхождения или вызывает ValueError
S.rindex(str, [start],[end])	Поиск подстроки в строке. Возвращает номер последнего вхождения или вызывает ValueError
S.replace(шаблон, замена[, maxcount])	Замена шаблона на замену. maxcount ограничивает количество замен
S.split(символ)	Разбиение строки по разделителю
S.isdigit()	Состоит ли строка из цифр
S.isalpha()	Состоит ли строка из букв
S.isalnum()	Состоит ли строка из цифр или букв
S.islower()	Состоит ли строка из символов в нижнем регистре
S.isupper()	Состоит ли строка из символов в верхнем регистре
S.isspace()	Состоит ли строка из неотображаемых символов (пробел, символ перевода страницы ('\f'), "новая строка" ('\n'), "перевод каретки" ('\r'), "горизонтальная табуляция" ('\t') и "вертикальная табуляция" ('\v'))
S.istitle()	Начинаются ли слова в строке с заглавной буквы
S.upper()	Преобразование строки к верхнему регистру
S.lower()	Преобразование строки к нижнему регистру
S.startswith(str)	Начинается ли строка S с шаблона str
S.endswith(str)	Заканчивается ли строка S шаблоном str
S.join(список)	Сборка строки из списка с разделителем S
ord(символ)	Символ в его код ASCII
chr(число)	Код ASCII в символ
S.capitalize()	Переводит первый символ строки в верхний регистр, а все остальные в нижний
S.center(width, [fill])	Возвращает отцентрованную строку, по краям которой стоит символ fill (пробел по умолчанию)
S.count(str, [start],[end])	Возвращает количество непересекающихся вхождений подстроки в диапазоне [начало, конец] (0 и длина строки по умолчанию)
S.expandtabs([tabsize])	Возвращает копию строки, в которой все символы табуляции заменяются одним или несколькими пробелами, в зависимости от текущего столбца. Если TabSize не указан, размер табуляции полагается равным 8 пробелам
S.lstrip([chars])	Удаление пробельных символов в начале строки
S.rstrip([chars])	Удаление пробельных символов в конце строки
S.strip([chars])	Удаление пробельных символов в начале и в конце строки
S.partition(шаблон)	Возвращает кортеж, содержащий часть перед первым шаблоном, сам шаблон, и часть после шаблона. Если шаблон не найден, возвращается кортеж, содержащий саму строку, а затем две пустых строки
S.rpartition(sep)	Возвращает кортеж, содержащий часть перед последним шаблоном, сам шаблон, и часть после шаблона. Если шаблон не найден, возвращается кортеж, содержащий две пустых строки, а затем саму строку
S.swapcase()	Переводит символы нижнего регистра в верхний, а верхнего – в нижний
S.title()	Первую букву каждого слова переводит в верхний регистр, а все остальные в нижний
S.zfill(width)	Делает длину строки не меньшей width, по необходимости заполняя первые символы нулями
S.ljust(width, fillchar=" ")	Делает длину строки не меньшей width, по необходимости заполняя последние символы символом fillchar
S.rjust(width, fillchar=" ")	Делает длину строки не меньшей width, по необходимости заполняя первые символы символом fillchar
S.format(*args, **kwargs)	Форматирование строки



ФУНКЦИИ для КОРТЕЖА tuple
tuple_ = (1, 2, 3,)
print(len(tuple_))  возвращает длину кортежа
a, b, c = tuple_    ф-я множественное присваивание, распаковка кортежа
tuple_[i]           обращение по индексу

for i in tuple_:    перебор поэлементно циклом for
    print(i)
ИЛИ
for i in range(len(tuple_)):
    print(tuple_[i])

print(max(tuple_)) вернуть наибольший эл-т
print(min(tuple_)) вернуть наименьший эл-т
print(sorted(tuple_)) отсортировать кортеж
print(count(tuple_)) вернуть кол-во повторений эл-та в кортеже
print(any(tuple_)) вернет true, если кортеж заполнен числами(числом), false - если кортеж пуст



ФУНКЦИИ для СЛОВАРЯ dict

dict_ = {'a':'01', 'b':'02', 'c':'03', 'd':'04'}
dict_ [0] = 9877 # добавить пару ключ-значение в существующий словарь
print(dict)

dict_.clear()   очистить словарь
dict_.copy()    вернуть копию словаря
dict_.items()   вернуть пары ключ-значение
dict_.keys()    вернуть ключи словаря           for k in dict_.keys()   вывести все ключи с красной строки
dict_.values()  вернуть значения словаря        for k in dict_.values() вывести все значения с красной строки

dict_.pop(key[, default])    удаляет ключ и возвращает значение. Если ключа нет, возвращает default (по умолчанию бросает исключение).
dict_.popitem()              удаляет и возвращает пару ключ-значение. Если словарь пуст, бросает исключение KeyError. Помните, что словари неупорядочены.
dict_.update([other])               добавляет пары ключ-значение из other, обновляя словарь. Существующие ключи перезаписываются. Возвращает None (не новый словарь!).
dict_.setdefault(key[, default])    возвращает значение ключа, но если его нет, не бросает исключение, а создает ключ со значением default (по умолчанию None).
dict_.get(key[, default])           возвращает значение ключа, но если его нет, не бросает исключение, а возвращает default (по умолчанию None).
classmethod dict_.fromkeys(seq[, value])    создает словарь с ключами из seq и значением value (по умолчанию None).



ФУНКЦИИ для МНОЖЕСТВА set
len(s) - число элементов в множестве (размер множества).
x in s - принадлежит ли x множеству s.

set_.add()      добавить эл-т
set_.remove()   удалить эл-т (если его не окажется - программа закончит работу с ошибкой)
set_.discard()  удалить эл-т (если его не окажется - программа НЕ закончит работу с ошибкой)
set_.clear()    очистить мн-во
set_.pop()      удаляет 1-й эл-т мн-ва - НЕИЗВЕСТНО какой, т.к. мн-ва НЕ упорядочены

операции с 2-мя мн-вами:
set_1 = set_.copy()             копия мн-ва set_ в переменную set_1
set_3 = set_2.union(set_, set_1)        объединение мн-тв set_, set_1, set_2 в переменную set_3
set_4 = set_.intersection(set_1)   пересечение (выведутся все одинаковые значения) мн-тв set_, set_1 в переменную set_4
set_5 = set_.difference(set_1)     выведутся все эл-ты из set_, которых нет в set_1


set_.update(other, ...); set |= other | ...                 объединение.
set_.intersection_update(other, ...); set &= other & ...    пересечение.
set_.difference_update(other, ...); set -= other | ...      вычитание.
set_.symmetric_difference_update(other); set ^= other       множество из элементов, встречающихся в одном множестве, но не встречающиеся в обоих.

set_.isdisjoint(other) - истина, если set и other не имеют общих элементов.
set_ == other - все элементы set принадлежат other, все элементы other принадлежат set.
set_.issubset(other) или set <= other - все элементы set принадлежат other.
set_.issuperset(other) или set >= other - аналогично.
set_.symmetric_difference(other); set ^ other - множество из элементов, встречающихся в одном множестве, но не встречающиеся в обоих.



LIST COMPREHENSION - ГЕНЕРАТОР СПИСКОВ - легкочитаемый упрощенный подход к созданию списка с помощью цикла for, а также if-else для определения того, что окажется в финальном списке

1. СПИСОК
list_ = [exp for item in iterable(повторяемом)] добавляем значение идя for item по какой-то коллекции данных


list_ = [item for item in range(5)] # 5 раз в список добавим значение 
равносильно записи
for item in range(5):
    list_.append(item)

    Создать список чисел от 1 до 100
list_1 = []
for i in range(1, 101):
list_1.append(i)
print(list_1) # [1, 2, 3,..., 100]

равносильно 

list_1 = [i for i in range(1, 101)]



2. ВЫБОРКА ПО ЗАДАННОМУ УСЛОВИЮ
list_1 = [exp for item in iterable (if conditional)]


Добавить условие (только чётные числа)
list_1 = [i for i in range(1, 101) if i % 2 == 0] # [2, 4, 6,..., 100]

Допустим, вы решили создать пары каждому из чисел (кортежи)
list_1 = [(i, i) for i in range(1, 101) if i % 2 == 0] # [(2, 2), (4, 4),...,
(100, 100)]

Также можно умножать, делить, прибавлять, вычитать. Например, умножить
значение на 2.
list_1 = [i * 2 for i in range(10) if i % 2 == 0]
print(list_1) # [0, 4, 8, 12, 16]
'''
# dict_ = {'1': 'a', '2': 'b', '3': 'c', '4': 'd', '5': 'e', '6': 'f'}
# print(dict_.items())
